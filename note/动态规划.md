#### lc121 买卖股票最佳时机

[url](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```java
/**
 * 状态转移方程 dp[i] = max{dp[i-1], prices[i]-min_price[i]}
 * dp[i]：表示到ith天为止能获得的最大利润
 * min_price[i] ：表示到ith天为止最小的价格
 * @param prices
 * @return
 */
public int maxProfit(int[] prices) {
    if (prices.length < 1) {
        return 0;
    }
    int[] dp = new int[prices.length];
    int[] minPrice = new int[prices.length];
    dp[0] = 0;
    minPrice[0] = prices[0];
    for (int i = 1; i < prices.length; i++) {
        if (prices[i] < minPrice[i-1]) {
            minPrice[i] = prices[i];
        } else {
            minPrice[i] = minPrice[i-1];
        }
        dp[i] = Math.max(dp[i-1], prices[i]-minPrice[i]);
    }
    return dp[prices.length-1];
}
```

#### lc122 买卖股票最佳时机II

```java
/**
 * 状态转移方程 dp[i] = dp[i-1] + max{prices[i]-prices[i-1], 0}
 * dp[i]：表示到ith天为止能获得的最大利润
 * @param prices
 * @return
 */
public int maxProfit(int[] prices) {
    int len = prices.length;
    int[] dp = new int[len];
    dp[0] = 0;

    for (int i=1; i < len; i++) {
        dp[i] = dp[i-1] + Math.max(prices[i]-prices[i-1], 0);
    }

    return dp[len-1];
}
```

[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii)

[188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv)

#### lc198 打家劫舍

```java
/**
 * 动态规划
 * 状态方程：dp[i] = max{nums[i] + dp[i-2], dp[i-1]}
 * 初始化：dp[0] = nums[0]; dp[1] = max{nums[0], nums[1]}
 * @param nums
 * @return
 */
public int rob(int[] nums) {

    if (nums.length <= 1) {
        return nums.length == 0 ? 0 : nums[0];
    }

    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    for (int i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);
    }
    return dp[nums.length-1];
}
```

#### lc322 零钱兑换

```java
public int coinChange(int[] coins, int amount) {
    int res = 0;
    // dp[i]数组定义：当金额为i时，需要最少dp[i]枚硬币
    int[] dp = new int[amount+1];
    // 将dp初始化为amount+1：因为金额为i时，硬币数量最多的一种情况是都为一元硬币，数据量为amount，amount+1表示表示正无穷，
    // 以便后面取最小值
    Arrays.fill(dp, amount+1);
    dp[0] = 0;
    for (int i = 1; i < dp.length; i++) {
        for (int j = 0; j < coins.length; j++) {
            if (coins[j] <= i) {
                dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
            }
        }

    }
    return dp[amount] > amount ? -1 : dp[amount];
}
```

#### LC518 零钱兑换II

```java
public int change(int amount, int[] coins) {
    int[] dp = new int[amount+1];
    dp[0] = 1;
    for (int coin : coins) {
        for (int i = coin; i <= amount; i++) {
            dp[i] += dp[i-coin];
        }
    }
    return dp[amount];
}
```

