#### lc121 买卖股票最佳时机

[url](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```java
/**
 * 状态转移方程 dp[i] = max{dp[i-1], prices[i]-min_price[i]}
 * dp[i]：表示到ith天为止能获得的最大利润
 * min_price[i] ：表示到ith天为止最小的价格
 * @param prices
 * @return
 */
public int maxProfit(int[] prices) {
    if (prices.length < 1) {
        return 0;
    }
    int[] dp = new int[prices.length];
    int[] minPrice = new int[prices.length];
    dp[0] = 0;
    minPrice[0] = prices[0];
    for (int i = 1; i < prices.length; i++) {
        if (prices[i] < minPrice[i-1]) {
            minPrice[i] = prices[i];
        } else {
            minPrice[i] = minPrice[i-1];
        }
        dp[i] = Math.max(dp[i-1], prices[i]-minPrice[i]);
    }
    return dp[prices.length-1];
}
```

#### lc122 买卖股票最佳时机II

```java
/**
 * 状态转移方程 dp[i] = dp[i-1] + max{prices[i]-prices[i-1], 0}
 * dp[i]：表示到ith天为止能获得的最大利润
 * @param prices
 * @return
 */
public int maxProfit(int[] prices) {
    int len = prices.length;
    int[] dp = new int[len];
    dp[0] = 0;

    for (int i=1; i < len; i++) {
        dp[i] = dp[i-1] + Math.max(prices[i]-prices[i-1], 0);
    }

    return dp[len-1];
}
```

[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii)

[188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv)

#### lc198 打家劫舍

```java
/**
 * 动态规划
 * 状态方程：dp[i] = max{nums[i] + dp[i-2], dp[i-1]}
 * 初始化：dp[0] = nums[0]; dp[1] = max{nums[0], nums[1]}
 * @param nums
 * @return
 */
public int rob(int[] nums) {

    if (nums.length <= 1) {
        return nums.length == 0 ? 0 : nums[0];
    }

    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    for (int i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);
    }
    return dp[nums.length-1];
}
```

#### lc322 零钱兑换

```java
public int coinChange(int[] coins, int amount) {
    int res = 0;
    // dp[i]数组定义：当金额为i时，需要最少dp[i]枚硬币
    int[] dp = new int[amount+1];
    // 将dp初始化为amount+1：因为金额为i时，硬币数量最多的一种情况是都为一元硬币，数据量为amount，amount+1表示表示正无穷，
    // 以便后面取最小值
    Arrays.fill(dp, amount+1);
    dp[0] = 0;
    for (int i = 1; i < dp.length; i++) {
        for (int j = 0; j < coins.length; j++) {
            if (coins[j] <= i) {
                dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
            }
        }

    }
    return dp[amount] > amount ? -1 : dp[amount];
}
```

#### LC518 零钱兑换II

```java
public int change(int amount, int[] coins) {
    int[] dp = new int[amount+1];
    dp[0] = 1;
    for (int coin : coins) {
        for (int i = coin; i <= amount; i++) {
            dp[i] += dp[i-coin];
        }
    }
    return dp[amount];
}
```

#### lc300 最长上升子序列

思路：

使用动态规划思想，dp[i]表示到nums[i]为止的最长上升子序列，转移方程是 dp[i] = max(dp[i], dp[j]+1) if (dp[j] > dp[i] and i>j)

上面转移方程的意思是：要在nums[i]之前找到小于 nums[i]的元素，如果有，即存在元素nums[j]<nums[i]并且j<i的时候，说明nums[i]可以添加在nums[j]之后增加子序列长度；如果没有，那以nums[i]结尾的最长子序列就是nums[i]本身。

举个例子：

> 将数组（7， 9， 6， 10， 7， 1， 3）的元素分别记为 （a1, a2, a3, a4, a5, a6, a7）
>
> 最开始a1 = 7,  令dp[ 1 ] = 1；
>
> 然后看下一个元素 a2 = 9, 令dp[ 2 ] = 1, 那么需要检查 i 前面是否有比他小的 因为 a1 < a2 而且 dp[ 1 ] + 1 > dp[ 2 ], 所以dp[ 2 ] = dp[ 1 ] + 1 == 2;
>
> 然后再看下一个元素 a3 = 6, 令 dp[ 3 ] = 1, 那么需要检查前面的元素 a1  与 a2 是否有比他小的， 一看没有，辣么 到目前为止，子序列就是他自己。
>
> 然后再看一下下一个元素 a4 = 10; 令 dp[ 4 ] = 1;  那么需要依次检查前面的元素 a1  与 a2 与 a3 是否有比他小的 , 一看a1比它小，而且呢，dp[ 1 ] + 1 > dp[ 4 ] 所以呢 dp[ 4 ] = dp[ 1 ] + 1 == 2, 说明此时 a1 与 a4 可以构成一个长度为 2 的上升子序列，再来看看还可不可以构成更长的子序列呢，所以咱们再来看看 a2 , a2 < a4 而且呢 dp[ 2 ] + 1 == 3 > dp[ 4 ] == 2  所以呢dp[ 4 ] = dp[ 2 ] + 1 == 3,  即将a4承接在a2后面比承接在a1后更好，承接在a2后面的序列为：a1 a2 a4 ，构成一个长度为 3 的上升子序列; 然后再来看 a3 , a3 < a4 但是可惜的是 d[ 3 ] + 1 == 2  < dp[ 4 ] == 3 ,  所以呢就不能把a4加在a3的后面 。
>
> 然后就是重复上述过程，找到最大的dp [ i ] 那么这个数就是最长上升子序列
> ————————————————
> 版权声明：本文为CSDN博主「ltrbless」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/ltrbless/article/details/81318935

时间复杂度：O(N^2)

```java
// 动态规划 O(N^2)
// dp[i]：到nums[i]为止的最长上升子序列
// dp[i] = max(dp[i], dp[j]+1) if dp[j] > dp[i](j<i)
public int lengthOfLIS(int[] nums) {
    int[] dp = new int[nums.length];
    for (int i = 0; i < dp.length; i++) {
        dp[i] = 1;
    }

    int maxLen = 0;

    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j]+1);
            }
        }
        maxLen = Math.max(maxLen, dp[i]);
    }
    return maxLen;
}
```

二分查找：

```java
public int lengthOfLIS2(int[] nums) {
    // tails[i]表示的是所有长度为i+1的递增子序列中的最小的尾部
    int[] tails = new int[nums.length];
    int size = 0;
    for (int x : nums) {
        int i = 0;
        int j = size;
        while (i != j) {
            int m = i + (j-i) / 2;
            // 找到最后一个大于x的tail
            if (tails[m] < x) {
                i = m + 1;
            }else {
                j = m;
            }
        }
        // 如果 tails[i-1] < x <= tails[i]，则更新tail[i]
        tails[i] = x;
        // 如果所有的tail都小于x，则将将x添加进去，并更新size
        if (i == size) {
            ++ size;
        }
    }
    return size;
}
```

