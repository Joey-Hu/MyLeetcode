#### lc3 无重复字符的最长子串

[url](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

```java
public int lengthOfLongestSubstring(String s) {

    if (s.length() == 0) {
        return 0;
    }

    Set<Character> set = new HashSet<>();
    int ans = 0;
    int start = 0;
    int end = 0;

    while (end < s.length()) {
        if (set.add(s.charAt(end))) {
            end ++;
            ans = Math.max(ans, end - start);
        }else {
            // 存在相同字符，就把start向右移动，并删除 s[start]，直到不存在相同字符
            set.remove(s.charAt(start));
            start ++;
        }
    }
    return ans;
}
```

[159. Longest Substring with At Most Two Distinct Characters 最多有2个不同字符的最长子串](https://www.cnblogs.com/grandyang/p/5185561.html)




#### lc15 三数之和

[url](https://leetcode.com/problems/3sum/)

```java
// 注意先进行排序，首先确定一个元素，再在后面的元素中找到另外两个符合要求的元素
public List<List<Integer>> threeSum(int[] nums) {

    List<List<Integer>> res = new ArrayList<>();

    // 首先对进行 nums 进行排序
    Arrays.sort(nums);

    for (int i = 0; i < nums.length-2; i++) {
        // 去重
        if (i == 0 || (i > 0 && nums[i] != nums[i-1])) {
            int num1 = nums[i];
            int start = i+1;
            int end = nums.length-1;
            while (start < end) {
                List<Integer> temp = new ArrayList<>();
                if (nums[start] + nums[end] == -num1) {
                    temp.add(num1);
                    temp.add(nums[start]);
                    temp.add(nums[end]);
                    res.add(new ArrayList<Integer>(temp));
                    // 去重
                    while (start < end && nums[start+1] == nums[start]) {
                        start ++;
                    }
                    start ++;
                    while (start < end && nums[end-1] == nums[end]) {
                        end --;
                    }
                    end --;
                }else if (nums[start] + nums[end] > -num1) {
                    while (start < end && nums[end-1] == nums[end]) {
                        end --;
                    }
                    end --;
                }else {
                    while (start < end && nums[start+1] == nums[start]) {
                        start ++;
                    }
                    start ++;
                }
            }

        }

    }
    return res;
}
```

#### lc42 接雨水

对撞指针

```javascript
public int trap(int[] height) {
    // 左右指针
    int left = 0;
    int right = height.length - 1;
    // 记录左右最大高度
    int maxLeft = 0;
    int maxRight = 0;
    int res = 0;

    while (left < right) {
        // 用于移动指针，if成立，移动左指针，否则，移动右指针
        if (height[left] <  height[right]) {
            // 更新最大值
            maxLeft = Math.max(height[left], maxLeft);
            // 获取雨水
            res += maxLeft - height[left];
            left ++;
        }else {
            maxRight = Math.max(height[right], maxRight);
            res += maxRight - height[right];
            right --;
        }
    }
    return res;
}
```

单调栈

建立一个单调递减的栈，如果出现一个元素比栈顶元素大的话，必然可以形成凹槽，此时我们只需要计算凹槽长度和边界的高度差那么必然可以计算出接水的面积。

```java

```

[Leetcode 42：接雨水（超详细的解法！！！）](https://blog.csdn.net/qq_17550379/article/details/84945427)lc234回文链表

```java
/**
     * 逆转一半，然后逐个比较
     * @param head
     * @return
     */
    public boolean isPalindrome2(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;

        // find the middle node
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }

        // 奇数节点，将slow节点移动到下个节点
        if (fast != null) {
            slow = slow.next;
        }

        // 逆转后半部分节点
        slow = reverse(slow);
        fast = head;

        while (slow != null && fast != null) {
            if (slow.val != fast.val) {
                return false;
            }
            slow = slow.next;
            fast = fast.next;
        }
        return true;
    }
```

#### lc141 环形链表

```java
/**
 * 快慢指针
 * @param head
 * @return
 */
public boolean hasCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;

    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) {
            return true;
        }
    }
    return false;
}
```

