#### lc78 集合的所有子集

[url](https://www.nowcoder.com/practice/c333d551eb6243e0b4d92e37a06fbfc9?tpId=117&&tqId=34948&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

```java
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> track = new LinkedList<>();
    Arrays.sort(nums);
    backtrack(track, new ArrayList<Integer>(), nums, 0);
    return track;
}

private void backtrack(List<List<Integer>> track, ArrayList<Integer> tempList, int[] nums, int start) {
    // 没有结束条件
    track.add(new ArrayList<>(tempList));

    for (int i = start; i < nums.length; i++) {
        tempList.add(nums[i]);
        backtrack(track, tempList, nums, i+1);
        tempList.remove(tempList.size() - 1);
    }
}
```

#### lc46 全排列

```java
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> track = new ArrayList<>();

    backtrack(nums, track, new ArrayList<Integer>());
    return track;
}

private void backtrack(int[] nums, List<List<Integer>> track, ArrayList<Integer> tempList) {
    // 结束条件
    if (tempList.size() == nums.length) {
        track.add(new ArrayList<>(tempList));
    }else {
        for (int i = 0; i < nums.length; i++) {
            // 不合法选项
            if (tempList.contains(nums[i])) {
                continue;
            }
            tempList.add(nums[i]);
            // 递归
            backtrack(nums, track, tempList);
            // 回溯
            tempList.remove(tempList.size()-1);
        }
    }
}
```

[A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partioning)](https://leetcode.com/problems/permutations/discuss/18239/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partioning))

#### lc39 组合总和

```java
public List<List<Integer>> combinationSum(int[] candidates, int target) {

    List<List<Integer>> track = new ArrayList<>();
    Arrays.sort(candidates);
    backtrack(candidates, track, new ArrayList<Integer>(), target, 0);
    return track;
}

private void backtrack(int[] candidates, List<List<Integer>> track, ArrayList<Integer> tempList, int remain, int
                       start) {
    if (remain < 0) {
        return;
    }else if(remain == 0) {
        track.add(new ArrayList<>(tempList));
    }else {
        for (int i = start; i < candidates.length; i++) {
            tempList.add(candidates[i]);
            backtrack(candidates, track, tempList, remain-candidates[i], i);
            tempList.remove(tempList.size()-1);
        }
    }
}
```

