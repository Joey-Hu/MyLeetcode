#### lc69 sqrt(x)

思路；二分查找（右边界），在 1-x 之间查找 sqrt(x)

```java
public int mySqrt(int x) {
        if (x == 0) {
            return 0;
        }
        int low = 1;
        int high = x;

        while (low <= high) {
            int mid = low + (high - low) / 2;
            int sqrt = x / mid;
            if (sqrt == mid) {
                return mid;
            }else if (sqrt > mid) {
                low = mid + 1;
            }else {
                high = mid - 1;
            }
        }
        return high;
    }
```

#### lc33 搜索排序旋转数组

思路：二分查找
 * 先找到最小值的下标，然后根据最后一个元素与target的大小
 * 确定是在左半边找(target > nums[len-1])还是在右半边(target <= nums[len-1])找
 * 然后在有序的那一半利用二分查找找到 target

```java
/** 
 * O(logN)
 */
public int search(int[] nums, int target) {
    int minIndex = findMinIndex(nums);
    if (nums[minIndex] == target) {
        return minIndex;
    }
    int low = (target <= nums[nums.length - 1]) ? minIndex : 0;
    int high = (target <= nums[nums.length - 1]) ? nums.length-1 : minIndex;

    // 基本的二分查找
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (nums[mid] == target) {
            return mid;
        }else if (target > nums[mid]) {
            low = mid + 1;
        }else {
            high = mid-1;
        }
    }
    return -1;
}

public int findMinIndex(int[] nums) {
    int low = 0;
    int high = nums.length - 1;
    while (low < high) {
        int mid = low + (high - low) / 2;
        if (nums[mid] > nums[high]) {
            low = mid + 1;
        }else {
            high = mid;
        }
    }
    return low;
}
```

#### lc162 寻找峰值

```java
// O(logN)
// 思路1：使用二分查找，重点在于mid值的判断：判断nums[mid]和nums[mid+1]大小
public int findPeakElement(int[] nums) {
    int low = 0;
    int high = nums.length - 1;

    while (low < high) {
        int mid1 = low + (high - low) / 2;
        int mid2 = mid1 + 1;
        if (nums[mid1] < nums[mid2]) {
            low = mid2;
        }else {
            high = mid1;
        }
    }
    return low;
}

// O(N)
// 思路2：一次遍历
public int findPeakElement(int[] nums) {
    int peak = 0;
    int max = Integer.MIN_VALUE;

    for (int i = 0; i < nums.length; i++) {
        if (nums[i] > max) {
            max = nums[i];
            peak = i;
        }
    }
    return peak;
}
```

