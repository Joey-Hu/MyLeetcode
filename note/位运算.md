#### 牛客题霸-算法篇-进制转换

[url]( https://www.nowcoder.com/practice/2cc32b88fff94d7e8fd458b8c7b25ec1?tpId=117&&tqId=35037&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

```java
public class Solution {
    /**javascript:void(0);
     * 进制转换
     * @param M int整型 给定整数
     * @param N int整型 转换到的进制
     * @return string字符串
     */
    public String solve (int M, int N) {
        // write code here
        StringBuilder sb = new StringBuilder();
        int positive = Math.abs(M);
        while (positive > 0) {
            int digit = positive % N;
            if (digit >=0 && digit < 10) {
                sb.insert(0, (char)(digit+'0')); 
            }else {
                sb.insert(0, (char)(digit - 10 + 'A'));
            }
            
            positive = positive / N;
        }
        return M >=0 ? sb.toString() : sb.insert(0, '-').toString();
    }
}
```

#### 牛客题霸-算法篇-数组中只出现一次的数字

[url](https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=117&&tqId=34997&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

思路：从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其他数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0，也就是说在这个结果数字的二进制表示中至少就有一位为1。我们在结果数字中找到第一个为1的位的位置，记为第N位。现在我们以第N位是不是1为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N位都为1，而第二个子数组的每个数字的第N位都为0。

现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其他数字都出现了两次。因此到此为止，所有的问题我们都已经解决。

```java
public class Solution {
    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
        int bitRes = array[0];
        for (int i = 1; i < array.length; i++) {
            bitRes ^= array[i];
        }
        
        int firstOne = findFirstOne(bitRes);
        for (int i = 0; i < array.length; i++){
            if (isOne(array[i], firstOne)) {
                num1[0] ^= array[i];
            }else {
                num2[0] ^= array[i];
            }
        }
    }
    
    // 找到第一个1的索引
    private int findFirstOne(int bitRes) {
        int idx = 0;
        while (((bitRes & 1) == 0) && idx < 32) {
            bitRes >>= 1;
            idx ++;
        }
        return idx;
    }
    
    // 判断第index位置的元素是不是1
    private boolean isOne(int num, int index) {
        return ((num >> index) & 1) == 1;
    }
}
```

#### 牛客题霸-算法篇-缺失数字

[url](https://www.nowcoder.com/practice/9ce534c8132b4e189fd3130519420cde?tpId=117&&tqId=35026&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

1. 求和，然后逐个减去a[i]，时间复杂度O(N)
2. 二分查找O(logN)

```java
public class Solution {
    /**
     * 找缺失数字
     * @param a int整型一维数组 给定的数字串
     * @return int整型
     */
    public int solve (int[] a) {
        // write code here
        int len = a.length;
        int sum = len* (len + 1) / 2;
        
        for (int i = 0; i < a.length; i++) {
            sum -= a[i];
        }
        return sum;
    }
}

public class Solution {
    /**
     * 找缺失数字
     * @param a int整型一维数组 给定的数字串
     * @return int整型
     */
    public int solve (int[] a) {
        // write code here
        int low = 0;
        int high = a.length-1;
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (a[mid] <= mid) {
                low = mid + 1;
            }else {
                high = mid;
            }
        }
        return low;
    }
}
```

