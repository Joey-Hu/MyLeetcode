#### 牛客题霸-算法篇-两数之和

[url](https://www.nowcoder.com/practice/20ef0972485e41019e39543e8e895b7f?tpId=117&&tqId=34983&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

哈希，一次遍历

```java
public class Solution {
    /**
     * 
     * @param numbers int整型一维数组 
     * @param target int整型 
     * @return int整型一维数组
     */
    public int[] twoSum (int[] numbers, int target) {
        // write code here
        Map<Integer, Integer> numIndex = new HashMap<>();
        int[] res = new int[2];
        for (int i = 0; i < numbers.length; i ++) {
            int complement = target - numbers[i];
            if (numIndex.containsKey(complement)) {
                res[0] = numIndex.get(complement) + 1;
                res[1] = i + 1;
            }
            numIndex.put(numbers[i], i);
        }
        return res;
    }
}
```

#### 牛客题霸-算法篇-合并两个有序数组

[url](https://www.nowcoder.com/practice/89865d4375634fc484f3a24b7fe65665?tpId=117&&tqId=34943&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

同 leetcode 88

双指针，

```java
public class Solution {
    public void merge(int A[], int m, int B[], int n) {
        int pos = m + n - 1;
        int pos1 = m - 1;
        int pos2 = n - 1;
        
        while (pos1 >= 0 && pos2 >= 0 && pos >= 0) {
            if (A[pos1] >= B[pos2]) {
                A[pos--] = A[pos1];
                pos1 -- ;
            }else {
                A[pos--] = B[pos2];
                pos2 --;
            }
        }
        while (pos >= 0 && pos2 >= 0) {
            A[pos--] = B[pos2--];
        }
    }
}
```

#### 牛客题霸-算法篇-螺旋矩阵

[url](https://www.nowcoder.com/practice/7edf70f2d29c4b599693dc3aaeea1d31?tpId=117&&tqId=34959&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

同leetcode54

此题注意避免重复输出的判断条件

```java
public List<Integer> spiralOrder(int[][] matrix) {
    List<Integer> res = new ArrayList<>();
    int top = 0;
    int bottom = matrix.length-1;
    int left = 0;
    int right = matrix[0].length-1;

    while (top <= bottom && left <= right) {
        // right
        if (left <= right) {
            for (int j = left; j <= right; j++) {
                res.add(matrix[top][j]);
            }
            top ++;
        }

        // down
        if (top <= bottom) {
            for (int i = top; i <= bottom; i++) {
                res.add(matrix[i][right]);
            }
            right --;
        }
            

        // Traverse left
        // 注意这里的判断条件：避免重复输出
        if (top <= bottom) {
            for (int j = right; j >= left; j--) {
                res.add(matrix[bottom][j]);
            }
            bottom --;
        }

        // Traverse up
        // 注意这里的判断条件：避免重复输出
        if (left <= right) {
            for (int i = bottom; i >= top; i--) {
                res.add(matrix[i][left]);
            }
            left ++;
        }
    }
    return res;
}
```

#### 牛客题霸-算法篇-数组中相加和为0的三元组

[url](https://www.nowcoder.com/practice/345e2ed5f81d4017bbb8cc6055b0b711?tpId=117&&tqId=34975&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

时间复杂度：O(NlogN)

同 leetcode

```java
public List<List<Integer>> threeSum(int[] nums) {
    // 排序
    Arrays.sort(nums);
    List<List<Integer>> res = new LinkedList<>();
    for (int i = 0; i < nums.length - 2; i ++) {

        if (i == 0 || (i > 0 && nums[i] != nums[i-1])) {
            int low = i + 1;
            int high = nums.length - 1;

            while(low < high) {
                if (nums[low] + nums[high] == -nums[i]) {
                    res.add(Arrays.asList(nums[i], nums[low], nums[high]));
                    while (low < high && nums[low] == nums[low + 1]) {
                        low ++;
                    }

                    while (low < high && nums[high] == nums[high - 1]) {
                        high --;
                    }
                    low ++;
                    high --;
                } else if (nums[low] + nums[high] > -nums[i]) {
                    while (low < high && nums[high] == nums[high-1]) {
                        high --;
                    }
                    high --;
                } else {
                    while (low < high && nums[low] == nums[low+1]) {
                        low ++;
                    }
                    low ++;
                }
            }
        }
    }
    return res;
}
```

#### 牛客题霸-算法篇-在转动过的有序数组中寻找目标值

[url](https://www.nowcoder.com/practice/7cd13986c79d4d3a8d928d490db5d707?tpId=117&&tqId=34969&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

同 leetcode 33

关键点在于中间值和右边界的判断

```java
public class Solution {
    /**
     * @param A int整型一维数组 
     * @param target int整型 
     * @return int整型
     */
    public int search (int[] A, int target) {
        // write code here
        int low = 0; 
        int high = A.length - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (A[mid] == target) {
                return mid;
            }
            // 右半边有序
            if (A[mid] < A[high]) {
                // 在有序半边首尾元素判断
                if (A[mid] < target && target <= A[high]) {
                    low = mid + 1;
                }else {
                    high = mid - 1;
                }
            }else { // 左半边有序
                if (target >= A[low] && A[mid] > target) {
                    high = mid - 1;
                }else {
                    low = mid + 1;
                }
            }
        }
        return -1;
    }
}
```

#### 牛客题霸-算法篇-矩阵最小路径和

[url]()

同 leetcode 

动态规划，找到子问题，到矩阵每一个点的最小路径和

```java
public class Solution {
    /**
     * 
     * @param matrix int整型二维数组 the matrix
     * @return int整型
     */
    public int minPathSum (int[][] matrix) {
        // write code here
        int rows = matrix.length;
        int cols = matrix[0].length;
        int[][] dp = new int[rows][cols];
        dp[0][0] = matrix[0][0];
        
        // 最上面一行只能一直往右得到
        for (int j = 1; j < cols; j++) {
            dp[0][j] = dp[0][j-1] + matrix[0][j];
        }
        
        // 同理，最左边一行只能一直向下得到
        for (int i = 1; i < rows; i++) {
            dp[i][0] = dp[i-1][0] + matrix[i][0];
        }
        
        // 遍历
        for (int i = 1; i < rows; i ++) {
            for (int j = 1; j < cols; j ++) {
                // 每个元素选择左边和上边最小的元素得到最小路径和
                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + matrix[i][j];
            }
        }
        return dp[rows-1][cols-1];
    }
}
```

#### 牛客题霸-算法篇-在两个长度相等的排序数组中找上中位数

[url](https://www.nowcoder.com/practice/6fbe70f3a51d44fa9395cfc49694404f?tpId=190&&tqId=35216&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

双指针分别指向两个数组，按大小顺序移动，移动次数为数组长度（题目中说的偶数奇数情况根本没用，因为两个数组长度相等，
不可能得到奇数个数字，中位数必然是第 arr1.size() 个），指针移完了就取两个数组中小的。

```java
public class Solution {
    /**
     * find median in two sorted array
     * @param arr1 int整型一维数组 the array1
     * @param arr2 int整型一维数组 the array2
     * @return int整型
     */
    public int findMedianinTwoSortedAray (int[] arr1, int[] arr2) {
        // write code here
        int index1 = 0;
        int index2 = 0;
        for (int i=arr1.length; i>1; i--){
            if (arr1[index1] <= arr2[index2]) {
                index1 ++;
            }else {
                index2 ++;
            }
        }
        return Math.min(arr1[index1], arr2[index2]);
    }
}
```
#### 牛客题霸-算法篇-数组中未出现的最小正整数

[url](https://www.nowcoder.com/practice/8cc4f31432724b1f88201f7b721aa391?tpId=190&&tqId=35388&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

要求: 时间复杂度为O(n)，空间复杂度为O(1)

先获得数组中正数元素的个数count以及它们的和，然后获得1到（count+1）元素之和，两者之差就是最小的正整数

```java
public class Solution {
    /**
     * return the min number
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int minNumberdisappered (int[] arr) {
        // write code here
        int count = 0;
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > 0) {
                sum += arr[i];
                count ++;
            }
        }
        
        int sum2 = (count + 1)*(count + 2) / 2;
        return sum2 - sum;
    }
}
```

#### 牛客题霸-算法篇-顺时针旋转矩阵

[url](https://www.nowcoder.com/practice/2e95333fbdd4451395066957e24909cc?tpId=190&&tqId=35208&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

先沿水平中线翻转，再沿主对角线翻转

```java
public class Solution {
    public int[][] rotateMatrix(int[][] mat, int n) {
        // write code here
        if (n == 0 || n == 1) {
            return mat;
        }
        
        // top dowm switch
        for (int i = 0; i < n/2; i++) {
            for (int j = 0; j < n; j++) {
                swap(mat, i, j, n-i-1, j);
            }
        }
        
        // main diagonal switch
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < i; j ++) {
                swap(mat, i, j, j, i);
            }
        }
        return mat;
    }
    
    private void swap(int[][] mat, int i1, int j1, int i2, int j2) {
        int temp = mat[i1][j1];
        mat[i1][j1] = mat[i2][j2];
        mat[i2][j2] = temp;
    }
}
```

 	#### 牛客题霸-算法篇-旋转数组

[url](https://www.nowcoder.com/practice/e19927a8fd5d477794dac67096862042?tpId=190&&tqId=36253&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

先整体逆向数组，然后以M为分割点分别逆向两个部分

```java
public class Solution {
    /**
     * 旋转数组
     * @param n int整型 数组长度
     * @param m int整型 右移距离
     * @param a int整型一维数组 给定数组
     * @return int整型一维数组
     */
    public int[] solve (int n, int m, int[] a) {
        // when m greater than n
        m = m % n;
        // reverse the whole array
        reverse(a, 0, n-1);
        //reverse left part
        reverse(a, 0, m-1);
        // reverse right part
        reverse(a, m, n-1);
        return a;
    }
    
    private void reverse(int[] a, int start, int end) {
        while (start < end) {
            int temp = a[start];
            a[start] = a[end];
            a[end] = temp;
            start ++;
            end --;
        }
    }
}
```

#### 牛客题霸-算法篇-数组中的逆序对(undone)

[url](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=190&&tqId=35588&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

1. 暴力解法（双重遍历）O(N^2)
2. 分治思想，采用归并排序的思路处理

https://cuijiahua.com/blog/2018/01/basis_35.html

```c++
class Solution {
public:
    int InversePairs(vector<int> data) {
        if(data.size() == 0){
            return 0;
        }
        // 排序的辅助数组
        vector<int> copy;
        for(int i = 0; i < data.size(); ++i){
            copy.push_back(data[i]);
        }
        return InversePairsCore(data, copy, 0, data.size() - 1) % 1000000007;
    }
    long InversePairsCore(vector<int> &data, vector<int> &copy, int begin, int end){
        // 如果指向相同位置，则没有逆序对。
        if(begin == end){
            copy[begin] = data[end];
            return 0;
        }
        // 求中点
        int mid = (end + begin) >> 1;
        // 使data左半段有序，并返回左半段逆序对的数目
        long leftCount = InversePairsCore(copy, data, begin, mid);
        // 使data右半段有序，并返回右半段逆序对的数目
        long rightCount = InversePairsCore(copy, data, mid + 1, end);
        
        int i = mid; // i初始化为前半段最后一个数字的下标
        int j = end; // j初始化为后半段最后一个数字的下标
        int indexcopy = end; // 辅助数组复制的数组的最后一个数字的下标
        long count = 0; // 计数，逆序对的个数，注意类型
        
        while(i >= begin && j >= mid + 1){
            if(data[i] > data[j]){
                copy[indexcopy--] = data[i--];
                count += j - mid;
            }
            else{
                copy[indexcopy--] = data[j--];
            }
        }
        for(;i >= begin; --i){
            copy[indexcopy--] = data[i];
        }
        for(;j >= mid + 1; --j){
            copy[indexcopy--] = data[j];
        }
        return leftCount + rightCount + count;
    }
};
```

#### 牛客题霸-算法篇-寻找峰值

[url](https://www.nowcoder.com/practice/1af528f68adc4c20bf5d1456eddb080a?tpId=190&&tqId=35434&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

题目较简单，注意边界条件即可

```java
public class Solution {
    /**
     * 寻找最后的山峰
     * @param a int整型一维数组 
     * @return int整型
     */
    public int solve (int[] a) {
        int res = 0;
        for (int i = 0; i < a.length; i++) {
            if (i == 0) {
                if (a[i] > a[i+1]) {
                    res = i;
                }
            }else if (i == a.length-1) {
                if (a[i] > a[i-1]) {
                    res = i;
                }
            }else if (a[i] > a[i-1] && a[i] > a[i+1] && i > res) {
                res = i;
            }
        }
        return res;
    }
}
```

#### 牛客题霸-算法篇-调整数组顺序使奇数位于偶数前面

[url](https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=190&&tqId=35985&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

1. 使用辅助数组，一个存储奇数，一个存储偶数，然后两个数组合并即可

2. in-place算法

```java
public class Solution {
    public void reOrderArray(int [] array) {
        int len = array.length;
        int[] even = new int[len];
        int evenIdx = 0;
        int oddIdx = 0;
        for (int i = 0; i < len; i++) {
            if (array[i] % 2 == 1) {
                array[oddIdx++] = array[i];
            }else {
                even[evenIdx++] = array[i];
            }
        }
        for (int i = 0; i < evenIdx; i++) {
            array[oddIdx++] = even[i];
        }
    }
}
```

#### lc31 下一个排列

思路：

* 从右往左遍历，找到第一组前一个比后一个小的位置，标记为i
* 然后再从右往左遍历一次，找到第一个比 nums[i]大的数，位置标记为j
* 交换i和j位置上的数，然后将i后面的数全部反转（即reverse(i + 1))

```java
public void nextPermutation(int[] nums) {
    if (nums.length == 0 || nums.length == 1 || nums == null) {
        return;
    }

    int i = nums.length - 2;
    // 从右往左遍历，找到第一组前一个比后一个小的位置，标记为i
    while (i >= 0 && nums[i] >= nums[i+1]) {
        i --; 
    }
    if (i >= 0) {
        int j = nums.length - 1;
        // 然后再从右往左遍历一次，找到第一个比 nums[i]大的数，位置标记为j
        while (j > i && nums[j] <= nums[i]) {
            j--;
        }
        // 交换
        swap(nums, i, j);
    }
    // 翻转
    reverse(nums, i+1, nums.length-1);
}

private void reverse(int[] nums, int i, int j) {
    while (i < j) {
        swap(nums, i++, j--);
    }
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

#### lc56 合并区间

* 先按首位进行排序
* 接下来,如何判断两个区间是否重叠呢?比如 a = [1,4],b = [2,3]
  当 a[1] >= b[0] 说明两个区间有重叠.
  但是如何把这个区间找出来呢?
  左边位置一定是确定，就是 a[0]，而右边位置是 max(a[1], b[1])
  所以,我们就能找出整个区间为:[1,4]

```java
public int[][] merge(int[][] intervals) {
    List<int[]> res = new ArrayList();
    if (intervals == null || intervals.length == 0) {
        return res.toArray(new int[0][]);
    } 

    // 根据首位排序
    Arrays.sort(intervals, (a, b)->(a[0]-b[0]));

    for (int i = 0; i < intervals.length; i++) {
        int left = intervals[i][0];
        int right = intervals[i][1];

        while (i < intervals.length-1 && intervals[i+1][0] <= right) {
            i++;
            right = Math.max(right, intervals[i][1]);
        }
        res.add(new int[]{left, right});
    }
    return res.toArray(new int[0][]);
}
```

#### lc41 缺失的第一个正数

思路：

1. 所有1....n之外的数都可以忽略，因为确实的第一个正整数一定是在1... n+1之间

2. 如何表示1... n之间的某个元素出现过：将 nums[idx-1] 变成负数用来表示该索引 idx 代表的数出现过
3. 找到第一个为正数的元素，该元素的下标代表的数就是缺失的第一个正数，如果没有找到，表示1... n的元素是满的

```java
public int firstMissingPositive(int[] nums) {
    int n = nums.length;

    // 将所有小于等于 0 或者是大于 n 的元素都标记成 n+1
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] <= 0 || nums[i] > n) {
            nums[i] = n + 1;
        }
    }

    // 将nums[nums[i]-1]变成负数用来表示该索引代表的数出现过
    for (int i = 0; i < n; i++) {
        // 为了防止重复元素的出现，由于之前已经出现过，所以此时的nums[i]被标记成负数，等到再次出现时，需要进行绝对值处理
        int num = Math.abs(nums[i]);
        if (num > n) {
            continue;
        }
        num --;
        if (nums[num] > 0) {
            nums[num] = -1 * nums[num];
        }
    }
    // 找到第一个为正数的元素，该元素的下标代表的数就是缺失的第一个正数
    for (int i = 0; i < n; i++) {
        if (nums[i] >= 0) {
            return i + 1;
        }
    }

    // 如果没有找到正数索引，表示nums中包含1...n所有元素
    return n + 1;
}
```

#### lc48 旋转图像

```java
public void rotate(int[][] matrix) {
    int rows = matrix.length;
    int cols = matrix[0].length;

    // 交换行
    for(int i = 0 ; i < rows / 2; i++) {
        for (int j = 0; j < cols; j++) {
            swap(matrix, i, j, rows-i-1, j);
        }
    }

    // 对角线交换
    for(int i = 0; i < rows; i++) {
        for (int j = 0; j < i; j++) {
            swap(matrix, i, j, j ,i);
        }
    }

}

private void swap(int[][] matrix, int i1, int j1, int i2, int j2) {
    int temp = matrix[i1][j1];
    matrix[i1][j1] = matrix[i2][j2];
    matrix[i2][j2] = temp;
}
```

