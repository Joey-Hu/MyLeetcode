#### 牛客题霸-算法-找到字符串的最长无重复字符子串

[url](https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4?tpId=190&&tqId=35220&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

使用hashSet

```java
public class Solution {
    /**
     * 
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int maxLength (int[] arr) {
        // write code here
        int maxLen = 0;
        if (arr.length == 0) {
            return 0;
        }
        int start = 0;
        int end = 0;
        Set<Integer> set = new HashSet<>();
        while (end < arr.length) {
            if (set.add(arr[end])) {
                end ++;
                maxLen = Math.max(maxLen, end-start);
            }else {
                // 存在相同字符，就把start向右移动，并删除 s[start]，直到不存在相同字符
                set.remove(arr[start]);
                start ++;
            }
        }
        return maxLen;
    }
}
```

#### 牛客题霸-算法-出现次数的 TopK 问题

使用桶排序

[url](https://www.nowcoder.com/practice/fd711bdfa0e840b381d7e1b82183b3ee?tpId=190&&tqId=36047&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

```java
public class Solution {
    /**
     * return topK string
     * @param strings string字符串一维数组 strings
     * @param k int整型 the k
     * @return string字符串二维数组
     */
    public String[][] topKstrings (String[] strings, int k) {
        // write code here
        ArrayList<String>[] bucket = new ArrayList[strings.length + 1];
        
        // 统计频率
        Map<String, Integer> stringFreq = new HashMap<>();
        for (String str : strings) {
            stringFreq.put(str, stringFreq.getOrDefault(str, 0) + 1);
        }
        
        // bucket sort
        for (String key : stringFreq.keySet()) {
            int freq = stringFreq.get(key);
            if (bucket[freq] == null) {
                bucket[freq] = new ArrayList<String>();
            }
            bucket[freq].add(key);
        }
        
        String[][] res = new String[k][2];
        int idx = 0;
        for (int i = bucket.length-1; i >= 0; i --) {
            if (bucket[i] != null) {
                // 注意这里需要将bucket[i]进行排序
                Collections.sort(bucket[i]);
                ArrayList<String> stringList = bucket[i];
                while (!stringList.isEmpty() && idx < k) {
                    res[idx][0] = stringList.get(0);
                    res[idx][1] = String.valueOf(i);
                    stringList.remove(0);
                    idx ++;
                }
            }
        }
        return res;
    }
}
```

 

#### 牛客题霸-算法-数组中出现次数超过一半的数字

[url](https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=190&&tqId=35371&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

1. HashMap

   时间复杂度：O(N)

   空间复杂度：O(N)

2. 候选法

   算法思想：如果两个数不相等，就消去这两个数，最坏情况下，每次消去一个众数和一个非众数，那么如果存在众数，最后留下的数肯定是众数。

```java
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        if (array.length <= 0) {
            return 0;
        }
        
        int cond = -1;
        int count = 0;
        for (int i = 0; i < array.length; i++) {
            if (count == 0) {
                cond = array[i];
                count ++;
            }
            else {
                if (cond == array[i]) {
                    count ++;
                }else {
                    count --;
                }
            }
        }
        // 验证 cond 是否是次数超过一半的数字
        count = 0;
        for (int i = 0; i < array.length; i ++) {
            if (cond == array[i]) {
                count ++;
            }
        }
        if (count > array.length / 2) {
            return cond;
        }
        return 0;
    }
}
```

#### 牛客题霸-算法-未排序正数数组中累加和为给定值的最长子数组长度

使用hashMap

时间复杂度：O(N)

```java
public class Solution {
    /**
     * max length of the subarray sum = k
     * @param arr int整型一维数组 the array
     * @param k int整型 target
     * @return int整型
     */
    public int maxlenEqualK (int[] arr, int k) {
        // write code here
        if (arr == null || arr.length == 0) {
            return 0;
        }
        
        Map <Integer, Integer> map = new HashMap<>();
        map.put(0, -1);
        int len = 0;
        int sum = 0;
        for (int i = 0; i < arr.length; i ++) {
            sum += arr[i];
            if (map.containsKey(sum - k)) {
                // i-map.get(sum-k) 表示当前 sum 的 idx 到上一个 sum-k 的 idx 之间的长度
                len = Math.max(len, i-map.get(sum-k));
            }
            if (!map.containsKey(sum)) {
                // 如果 map 不存在 key=sum 的记录，则记录当前的 sum 值以及 idx
                map.put(sum, i);
            }
        }
        return len;
    }
}
```

#### lc1 两数之和

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> numsMap = new HashMap();
    int[] res = new int[2];

    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (numsMap.get(complement) != null) {
            res[0] = numsMap.get(complement);
            res[1] = i;
            return res;
        }else {
            numsMap.put(nums[i], i);
        }
    }
    return res;
}
```

