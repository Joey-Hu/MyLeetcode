### 栈

#### 牛客题霸-算法篇-用两个栈实现队列

[url](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=190&&tqId=35202&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

leetcode 232

保证出栈是空的

```java
public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
        int res;
        while (!stack1.empty()) {
            stack2.push(stack1.pop());
        }
        
        res = stack2.pop();
        while (!stack2.empty()) {
            stack1.push(stack2.pop());
        }
        return res;
    }
}
```



#### lc20 有效括号序列

[url](https://www.nowcoder.com/practice/37548e94a270412c8b9fb85643c8ccc2?tpId=190&&tqId=35194&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

```java
public class Solution {
    /**
     * 
     * @param s string字符串 
     * @return bool布尔型
     */
    public boolean isValid (String s) {
        Stack<Character> parenthesesStack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            if (ch == '(' || ch == '[' || ch == '{') {
                parenthesesStack.push(ch);
            }else if (ch == ')') {
                if (!parenthesesStack.empty() && parenthesesStack.peek() == '(') {
                    parenthesesStack.pop();
                }else {
                    return false;
                }
            }else if (ch == ']') {
                if (!parenthesesStack.empty() && parenthesesStack.peek() == '[') {
                    parenthesesStack.pop();
                }else {
                    return false;
                }
            }else if (ch == '}') {
                if (!parenthesesStack.empty() && parenthesesStack.peek() == '{') {
                    parenthesesStack.pop();
                }else {
                    return false;
                }
            }
        }
        return parenthesesStack.empty();
    }
}
```

#### lc155 最小栈

最小栈的关键在于每次获取最小值的时间复杂度是O(1)，处理办法就是每次插入小于或等于最小值 min 的元素之前，先插入 preMin

```java
public class E155_MinStack {

    private Stack<Integer> stack;
    private Integer min;

    /** initialize your data structure here. */
    public E155_MinStack() {
        stack = new Stack<>();
        min = Integer.MAX_VALUE;
    }

    public void push(int x) {
        // 每次压入最小值之前，先压入次小值
        if (x <= min) {
            stack.push(min);
            min = x;
        }
        stack.push(x);
    }

    public void pop() {
        // 每次弹出最小值，后面跟着弹出次小值
        // 若判断出来是非最小值，也是弹出来了
        if (stack.pop().equals(min)) {
            minVal = minStack.pop();
        }
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
       return min;
    }
}
```

####  牛客题霸-算法篇-表达式求值（HARD）

```java
public class UNKNOW772_BasicCalculatorIII {

    public int calculate(String s) {

        int res = 0;
        int curRes = 0;
        int number = 0;
        char sign = '+';

        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            // 当字符是数字时
            if (Character.isDigit(ch)) {
                number = number * 10 + (int)(ch - '0');
            }else if (ch == '(') { // 当遇到左括号时，先递归计算括号内部结果，将结果返回给上一层
                int j = i;
                int count = 0;
                for (; i < s.length(); i++) {
                    if (s.charAt(i) == '(') {
                        count ++;
                    }else if (s.charAt(i) == ')') {
                        count --;
                    }
                    if (count == 0) {
                        break;
                    }
                }
                number = calculate(s.substring(j+1, i+1));
            }
            // 计算符
            if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || i == s.length() - 1) {
                switch (sign) {
                    case '+': curRes += number; break;
                    case '-': curRes -= number; break;
                    case '*': curRes *= number; break;
                    case '/': curRes /= number; break;
                }
                if (ch == '+' || ch == '-' || i == s.length()-1) {
                    res += curRes;
                    curRes = 0;
                }
                sign = ch;
                number = 0;
            }
        }
        return res;
    }
}
```



### 单调栈

#### 739. Daily Temperatures

[url](https://leetcode.com/problems/daily-temperatures/)

```java
public int[] dailyTemperatures(int[] T) {
    Stack<Integer> stack = new Stack<>();
    int[] res = new int[T.length];

    for (int i = 0; i < T.length; i++) {
        while (!stack.empty() && T[i] > T[stack.peek()]) {
            int idx = stack.pop();
            res[idx] = i - idx;
        }
        stack.push(i);
    }
    return res;
}
```

#### 496. Next Greater Element I

url: https://leetcode.com/problems/next-greater-element-i/

```java
public int[] nextGreaterElement(int[] nums1, int[] nums2) {
    Map<Integer, Integer> hashMap = new HashMap<>();
    Stack<Integer> stack = new Stack<>();
    int[] res = new int[nums1.length];

    for (int i = 0; i < nums2.length; i++) {
        while (!stack.empty() && nums2[i] > nums2[stack.peek()]) {
            hashMap.put(nums2[stack.pop()], nums2[i]);
        }
        stack.push(i);
    }

    for(int i = 0; i < nums1.length; i++) {
        res[i] = hashMap.getOrDefault(nums1[i], -1);
    }
    return res;
}
```

